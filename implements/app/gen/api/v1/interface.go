// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	SessionScopes = "Session.Scopes"
)

// Defines values for ContentType.
const (
	ContentTypeCheckbox    ContentType = "checkbox"
	ContentTypeHeading     ContentType = "heading"
	ContentTypeImg         ContentType = "img"
	ContentTypeLine        ContentType = "line"
	ContentTypeList        ContentType = "list"
	ContentTypeMentions    ContentType = "mentions"
	ContentTypeRadiobutton ContentType = "radiobutton"
	ContentTypeText        ContentType = "text"
)

// Defines values for LinePropertyType.
const (
	Blockquote LinePropertyType = "blockquote"
	Callout    LinePropertyType = "callout"
	Toggle     LinePropertyType = "toggle"
)

// Defines values for ListType.
const (
	Integer  ListType = "integer"
	Midpoint ListType = "midpoint"
)

// Defines values for Operation.
const (
	OperationCreate Operation = "create"
	OperationDelete Operation = "delete"
	OperationUpdate Operation = "update"
)

// Defines values for RecieveType.
const (
	RecieveTypeDelete RecieveType = "delete"
	RecieveTypeInsert RecieveType = "insert"
	RecieveTypeMove   RecieveType = "move"
	RecieveTypeUpdate RecieveType = "update"
)

// Defines values for Resource.
const (
	ResourceChoose    Resource = "choose"
	ResourceCommunity Resource = "community"
	ResourceElection  Resource = "election"
	ResourceLike      Resource = "like"
	ResourceMember    Resource = "member"
	ResourceMilestone Resource = "milestone"
	ResourcePost      Resource = "post"
	ResourceProject   Resource = "project"
	ResourceRole      Resource = "role"
	ResourceTag       Resource = "tag"
	ResourceTask      Resource = "task"
	ResourceThread    Resource = "thread"
	ResourceTopic     Resource = "topic"
	ResourceUser      Resource = "user"
)

// Defines values for SendType.
const (
	Current SendType = "current"
)

// Action 行動
type Action struct {
	Operations []Operation `json:"operations"`

	// Resource リソース
	// * user - ユーザー
	// * community - コミュニティ
	// * member - メンバー
	// * role - ロール
	// * topic - トピック
	// * thread - スレッド
	// * post - ポスト
	// * project - プロジェクト
	// * milestone - プロジェクトのマイルストーン
	// * task - プロジェクトのタスク
	// * tag - タグ
	// * election - 投票
	// * choose - 投票の選択肢
	// * like - 支持/不支持
	Resource Resource `json:"resource"`
}

// Activity アクティビティ
type Activity struct {
	// When UNIX時間（秒単位）
	When *UnixTime `json:"When,omitempty"`

	// Did 体験
	Did   Experience      `json:"did"`
	Where *Activity_Where `json:"where,omitempty"`
	Who   *Activity_Who   `json:"who,omitempty"`
}

// Activity_Where defines model for Activity.Where.
type Activity_Where struct {
	union json.RawMessage
}

// Activity_Who defines model for Activity.Who.
type Activity_Who struct {
	union json.RawMessage
}

// Agreement 合意
// * true - 合意する
// * false - 合意しない
type Agreement = bool

// CheckBox チェックボックス
type CheckBox struct {
	Values []CheckBoxElement `json:"values"`
}

// CheckBoxElement チェックボックスの要素
type CheckBoxElement struct {
	Checked bool `json:"checked"`

	// Value テキスト
	Value Text `json:"value"`
}

// ColorCode 16進数の色コード
type ColorCode = string

// Community コミュニティ
type Community struct {
	Id         ID   `json:"id"`
	Invitation bool `json:"invitation"`
	Name       Name `json:"name"`
}

// CommunityInvite コミュニティによる招待
type CommunityInvite struct {
	// At UNIX時間（秒単位）
	At      UnixTime      `json:"at"`
	Id      ID            `json:"id"`
	Message *ShortMessage `json:"message,omitempty"`

	// Role ロール
	Role  Role   `json:"role"`
	Users []User `json:"users"`
}

// Content 内容
type Content struct {
	Entity Content_Entity `json:"entity"`

	// Type 内容の種類
	// * text - テキスト
	// * heading - 見出し
	// * list - 箇条書き
	// * checkbox - チェックボックス
	// * radiobutton - ラジオボタン
	// * line - 水平線
	// * img - 画像
	// * mentions - メンション
	Type ContentType `json:"type"`
}

// Content_Entity defines model for Content.Entity.
type Content_Entity struct {
	union json.RawMessage
}

// ContentType 内容の種類
// * text - テキスト
// * heading - 見出し
// * list - 箇条書き
// * checkbox - チェックボックス
// * radiobutton - ラジオボタン
// * line - 水平線
// * img - 画像
// * mentions - メンション
type ContentType string

// CurrentLinesMessage 現在の全行
type CurrentLinesMessage = []Line

// DeletedLineMessage 削除した行
type DeletedLineMessage struct {
	// To 連番
	To OrderNumber `json:"to"`
}

// EditedLineMessage 行
type EditedLineMessage = Line

// Experience 体験
type Experience struct {
	// Operation 操作
	// * create - 作成
	// * update - 更新
	// * delete - 削除
	Operation Operation           `json:"operation"`
	Resource  Experience_Resource `json:"resource"`
}

// Experience_Resource defines model for Experience.Resource.
type Experience_Resource struct {
	union json.RawMessage
}

// Heading 見出し
type Heading struct {
	// Level 見出しレベル
	Level HeadingLevel `json:"level"`

	// Value テキスト
	Value Text `json:"value"`
}

// HeadingLevel 見出しレベル
type HeadingLevel = int

// HorizontalLine 水平線
type HorizontalLine struct {
	Size int `json:"size"`
}

// ID defines model for ID.
type ID = openapi_types.UUID

// Image 画像
type Image struct {
	Height *string `json:"height,omitempty"`
	Url    URL     `json:"url"`
	Width  *string `json:"width,omitempty"`
}

// Indent インデント
type Indent = int

// InsertedLineMessage 挿入した行
type InsertedLineMessage struct {
	// To 連番
	To OrderNumber `json:"to"`
}

// Like 支持/不支持
type Like struct {
	// By メンバー
	By      *Member       `json:"by,omitempty"`
	Comment *ShortMessage `json:"comment,omitempty"`
	Like    bool          `json:"like"`
}

// Limit defines model for Limit.
type Limit = int

// Line 行
type Line struct {
	Contents []Content `json:"contents"`

	// Order 連番
	Order OrderNumber `json:"order"`

	// Property 行の属性
	Property *LineProperty `json:"property,omitempty"`
}

// LineProperty 行の属性
type LineProperty struct {
	// Type 行の属性の種類
	// * toggle - トグル
	// * blockquote - 引用
	// * callout - 強調
	Type LinePropertyType `json:"type"`
}

// LinePropertyType 行の属性の種類
// * toggle - トグル
// * blockquote - 引用
// * callout - 強調
type LinePropertyType string

// List 箇条書き
type List struct {
	// Type リストの種類
	// * midpoint - 中黒
	// * integer - 数字
	Type   ListType      `json:"type"`
	Values []ListElement `json:"values"`
}

// ListElement リストの要素
type ListElement struct {
	// Indent インデント
	Indent Indent `json:"indent"`

	// Value テキスト
	Value Text `json:"value"`
}

// ListType リストの種類
// * midpoint - 中黒
// * integer - 数字
type ListType string

// Login ログイン
type Login struct {
	IpAddress       string `json:"ip_address"`
	OperationSystem string `json:"operation_system"`
	UserAgent       string `json:"user_agent"`
}

// LongMessage defines model for LongMessage.
type LongMessage = string

// Member メンバー
type Member struct {
	Id ID `json:"id"`

	// Role ロール
	Role *Role `json:"role,omitempty"`

	// User ユーザー
	User User `json:"user"`
}

// Mention メンション
type Mention struct {
	Id ID `json:"id"`

	// Resource リソース
	// * user - ユーザー
	// * community - コミュニティ
	// * member - メンバー
	// * role - ロール
	// * topic - トピック
	// * thread - スレッド
	// * post - ポスト
	// * project - プロジェクト
	// * milestone - プロジェクトのマイルストーン
	// * task - プロジェクトのタスク
	// * tag - タグ
	// * election - 投票
	// * choose - 投票の選択肢
	// * like - 支持/不支持
	Resource Resource `json:"resource"`
}

// Mentions defines model for Mentions.
type Mentions = []Mention

// MessagesToRecieve 受け取るメッセージ
type MessagesToRecieve struct {
	Entity MessagesToRecieve_Entity `json:"entity"`

	// Type 受け取るメッセージの種類
	// * insert - 挿入
	// * move - 移動
	// * update - 更新
	// * delete - 削除
	Type RecieveType `json:"type"`
}

// MessagesToRecieve_Entity defines model for MessagesToRecieve.Entity.
type MessagesToRecieve_Entity struct {
	union json.RawMessage
}

// MessagesToSend 送信されるメッセージ
type MessagesToSend struct {
	Entity MessagesToSend_Entity `json:"entity"`

	// Type 送信されるメッセージの種類
	// * current - 現在の全行
	Type SendType `json:"type"`
}

// MessagesToSend_Entity defines model for MessagesToSend.Entity.
type MessagesToSend_Entity struct {
	union json.RawMessage
}

// MovedLineMessage 移動した行
type MovedLineMessage struct {
	// From 連番
	From OrderNumber `json:"from"`

	// To 連番
	To OrderNumber `json:"to"`
}

// Name defines model for Name.
type Name = string

// Offset defines model for Offset.
type Offset = int

// Operation 操作
// * create - 作成
// * update - 更新
// * delete - 削除
type Operation string

// OrderNumber 連番
type OrderNumber = int

// Post ポスト
type Post struct {
	// At UNIX時間（秒単位）
	At       UnixTime  `json:"at"`
	Contents []Content `json:"contents"`

	// Created メンバー
	Created *Member `json:"created,omitempty"`
	Id      ID      `json:"id"`

	// Reaction リアクション
	Reaction Reaction `json:"reaction"`
}

// RadioButton ラジオボタン
type RadioButton struct {
	Values []RadioButtonElement `json:"values"`
}

// RadioButtonElement ラジオボタンの要素
type RadioButtonElement struct {
	Checked bool `json:"checked"`

	// Value テキスト
	Value Text `json:"value"`
}

// Reaction リアクション
type Reaction struct {
	// Dislikes 不支持数
	Dislikes int `json:"dislikes"`

	// Likes 支持数
	Likes int `json:"likes"`
}

// RecieveType 受け取るメッセージの種類
// * insert - 挿入
// * move - 移動
// * update - 更新
// * delete - 削除
type RecieveType string

// Resource リソース
// * user - ユーザー
// * community - コミュニティ
// * member - メンバー
// * role - ロール
// * topic - トピック
// * thread - スレッド
// * post - ポスト
// * project - プロジェクト
// * milestone - プロジェクトのマイルストーン
// * task - プロジェクトのタスク
// * tag - タグ
// * election - 投票
// * choose - 投票の選択肢
// * like - 支持/不支持
type Resource string

// Role ロール
type Role struct {
	Actions []Action `json:"actions"`
	Id      ID       `json:"id"`
	Name    Name     `json:"name"`
}

// SendType 送信されるメッセージの種類
// * current - 現在の全行
type SendType string

// ShortMessage defines model for ShortMessage.
type ShortMessage = string

// Text テキスト
type Text struct {
	// Option テキストの属性
	Option TextProperty `json:"option"`
	Value  LongMessage  `json:"value"`
}

// TextProperty テキストの属性
type TextProperty struct {
	// Bold 太字
	Bold bool `json:"bold"`

	// Color 16進数の色コード
	Color *ColorCode `json:"color,omitempty"`

	// Oblique 斜体
	Oblique bool `json:"oblique"`

	// Through 打ち消し戦
	Through bool `json:"through"`

	// Underline 下線
	Underline bool `json:"underline"`
	Url       *URL `json:"url,omitempty"`
}

// Thread スレッド
type Thread struct {
	// FirstPost ポスト
	FirstPost Post `json:"first_post"`
	Id        ID   `json:"id"`
	Reply     bool `json:"reply"`
}

// Topic 話題
type Topic struct {
	Contents []Content `json:"contents"`

	// Created メンバー
	Created *Member `json:"created,omitempty"`
	Id      ID      `json:"id"`

	// LastPost ポスト
	LastPost *Post `json:"last_post,omitempty"`
	Name     Name  `json:"name"`
}

// URL defines model for URL.
type URL = string

// UnixTime UNIX時間（秒単位）
type UnixTime = int

// User ユーザー
type User struct {
	Id    ID   `json:"id"`
	Image *URL `json:"image,omitempty"`
	Name  Name `json:"name"`
}

// UserInvite ユーザーが受けた招待
type UserInvite struct {
	// At UNIX時間（秒単位）
	At UnixTime `json:"at"`

	// Community コミュニティ
	Community Community     `json:"community"`
	Id        ID            `json:"id"`
	Message   *ShortMessage `json:"message,omitempty"`

	// Role ロール
	Role Role `json:"role"`
}

// CreateCommunityResponse defines model for CreateCommunityResponse.
type CreateCommunityResponse struct {
	Id ID `json:"id"`
}

// CreateTopicResponse defines model for CreateTopicResponse.
type CreateTopicResponse struct {
	Id ID `json:"id"`
}

// GetCommunityMemberResponse defines model for GetCommunityMemberResponse.
type GetCommunityMemberResponse struct {
	// Member メンバー
	Member           Member     `json:"member"`
	RecentActivities []Activity `json:"recent_activities"`
}

// ListActionResponse defines model for ListActionResponse.
type ListActionResponse struct {
	Operations []Operation `json:"operations"`
	Resources  []Resource  `json:"resources"`
}

// ListCommunityInviteResponse defines model for ListCommunityInviteResponse.
type ListCommunityInviteResponse struct {
	Invites []CommunityInvite `json:"invites"`
}

// ListCommunityMemberResponse defines model for ListCommunityMemberResponse.
type ListCommunityMemberResponse struct {
	Members []Member `json:"members"`
}

// ListCommunityRoleResponse defines model for ListCommunityRoleResponse.
type ListCommunityRoleResponse struct {
	Roles []Role `json:"roles"`
}

// ListPostLikeResponse defines model for ListPostLikeResponse.
type ListPostLikeResponse struct {
	Likes []Like `json:"likes"`
}

// ListPostResponse defines model for ListPostResponse.
type ListPostResponse struct {
	Posts []Post `json:"posts"`
}

// ListThreadResponse defines model for ListThreadResponse.
type ListThreadResponse struct {
	Threads []Thread `json:"threads"`
}

// ListTopicResponse defines model for ListTopicResponse.
type ListTopicResponse struct {
	Topics []Topic `json:"topics"`
}

// ListUserActivityResponse defines model for ListUserActivityResponse.
type ListUserActivityResponse struct {
	Activities []Activity `json:"activities"`
}

// ListUserInviteResponse defines model for ListUserInviteResponse.
type ListUserInviteResponse struct {
	Invites []UserInvite `json:"invites"`
}

// ListUserLoginActivityResponse defines model for ListUserLoginActivityResponse.
type ListUserLoginActivityResponse struct {
	Activities []Activity `json:"activities"`
}

// CreateCommunityRequest defines model for CreateCommunityRequest.
type CreateCommunityRequest struct {
	Invitation bool `json:"invitation"`
	Name       Name `json:"name"`
}

// CreateCommunityRoleRequest defines model for CreateCommunityRoleRequest.
type CreateCommunityRoleRequest struct {
	Actions []Action `json:"actions"`
	Name    Name     `json:"name"`
}

// CreatePostRequest defines model for CreatePostRequest.
type CreatePostRequest struct {
	Contents []Content `json:"contents"`
}

// CreateThreadRequest defines model for CreateThreadRequest.
type CreateThreadRequest struct {
	Contents []Content `json:"contents"`
}

// CreateTopicRequest defines model for CreateTopicRequest.
type CreateTopicRequest struct {
	Contents []Content `json:"contents"`
	Name     Name      `json:"name"`
}

// InviteCommunityRoleRequest defines model for InviteCommunityRoleRequest.
type InviteCommunityRoleRequest struct {
	Mention Mentions     `json:"mention"`
	Message ShortMessage `json:"message"`
}

// LikeRequest defines model for LikeRequest.
type LikeRequest struct {
	Comment *ShortMessage `json:"comment,omitempty"`
	Like    bool          `json:"like"`
}

// ReplyUserInviteRequest defines model for ReplyUserInviteRequest.
type ReplyUserInviteRequest struct {
	// Agree 合意
	// * true - 合意する
	// * false - 合意しない
	Agree Agreement `json:"agree"`
}

// UpdateCommunityRequest defines model for UpdateCommunityRequest.
type UpdateCommunityRequest struct {
	Name Name `json:"name"`
}

// UpdateCommunityRoleRequest defines model for UpdateCommunityRoleRequest.
type UpdateCommunityRoleRequest struct {
	Actions []Action `json:"actions"`
	Name    Name     `json:"name"`
}

// CreateCommunityJSONBody defines parameters for CreateCommunity.
type CreateCommunityJSONBody struct {
	Invitation bool `json:"invitation"`
	Name       Name `json:"name"`
}

// UpdateCommunityJSONBody defines parameters for UpdateCommunity.
type UpdateCommunityJSONBody struct {
	Name Name `json:"name"`
}

// ListCommunityInviteParams defines parameters for ListCommunityInvite.
type ListCommunityInviteParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// ListCommunityMemberParams defines parameters for ListCommunityMember.
type ListCommunityMemberParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// EditCommunityDescriptionParams defines parameters for EditCommunityDescription.
type EditCommunityDescriptionParams struct {
	Connection             string `json:"Connection"`
	Upgrade                string `json:"Upgrade"`
	SecWebSocketKey        string `json:"Sec-WebSocket-Key"`
	SecWebSocketVersion    string `json:"Sec-WebSocket-Version"`
	SecWebSocketExtensions string `json:"Sec-WebSocket-Extensions"`
}

// CreateCommunityRoleJSONBody defines parameters for CreateCommunityRole.
type CreateCommunityRoleJSONBody struct {
	Actions []Action `json:"actions"`
	Name    Name     `json:"name"`
}

// UpdateCommunityRoleJSONBody defines parameters for UpdateCommunityRole.
type UpdateCommunityRoleJSONBody struct {
	Actions []Action `json:"actions"`
	Name    Name     `json:"name"`
}

// InviteCommunityRoleJSONBody defines parameters for InviteCommunityRole.
type InviteCommunityRoleJSONBody struct {
	Mention Mentions     `json:"mention"`
	Message ShortMessage `json:"message"`
}

// ListCommunityTopicParams defines parameters for ListCommunityTopic.
type ListCommunityTopicParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// CreateCommunityTopicJSONBody defines parameters for CreateCommunityTopic.
type CreateCommunityTopicJSONBody struct {
	Contents []Content `json:"contents"`
	Name     Name      `json:"name"`
}

// ListCommunityThreadParams defines parameters for ListCommunityThread.
type ListCommunityThreadParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// CreateCommunityThreadJSONBody defines parameters for CreateCommunityThread.
type CreateCommunityThreadJSONBody struct {
	Contents []Content `json:"contents"`
}

// ListCommunityPostParams defines parameters for ListCommunityPost.
type ListCommunityPostParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// CreateCommunityPostJSONBody defines parameters for CreateCommunityPost.
type CreateCommunityPostJSONBody struct {
	Contents []Content `json:"contents"`
}

// ListPostLikeParams defines parameters for ListPostLike.
type ListPostLikeParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
	Like   bool   `form:"like" json:"like"`
}

// LikePostJSONBody defines parameters for LikePost.
type LikePostJSONBody struct {
	Comment *ShortMessage `json:"comment,omitempty"`
	Like    bool          `json:"like"`
}

// ListUserInviteParams defines parameters for ListUserInvite.
type ListUserInviteParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// ReplyInviteJSONBody defines parameters for ReplyInvite.
type ReplyInviteJSONBody struct {
	// Agree 合意
	// * true - 合意する
	// * false - 合意しない
	Agree Agreement `json:"agree"`
}

// ListUserLoginActivityParams defines parameters for ListUserLoginActivity.
type ListUserLoginActivityParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// EditUserProfileParams defines parameters for EditUserProfile.
type EditUserProfileParams struct {
	Connection             string `json:"Connection"`
	Upgrade                string `json:"Upgrade"`
	SecWebSocketKey        string `json:"Sec-WebSocket-Key"`
	SecWebSocketVersion    string `json:"Sec-WebSocket-Version"`
	SecWebSocketExtensions string `json:"Sec-WebSocket-Extensions"`
}

// ListUserActivityParams defines parameters for ListUserActivity.
type ListUserActivityParams struct {
	Limit  Limit  `form:"limit" json:"limit"`
	Offset Offset `form:"offset" json:"offset"`
}

// CreateCommunityJSONRequestBody defines body for CreateCommunity for application/json ContentType.
type CreateCommunityJSONRequestBody CreateCommunityJSONBody

// UpdateCommunityJSONRequestBody defines body for UpdateCommunity for application/json ContentType.
type UpdateCommunityJSONRequestBody UpdateCommunityJSONBody

// CreateCommunityRoleJSONRequestBody defines body for CreateCommunityRole for application/json ContentType.
type CreateCommunityRoleJSONRequestBody CreateCommunityRoleJSONBody

// UpdateCommunityRoleJSONRequestBody defines body for UpdateCommunityRole for application/json ContentType.
type UpdateCommunityRoleJSONRequestBody UpdateCommunityRoleJSONBody

// InviteCommunityRoleJSONRequestBody defines body for InviteCommunityRole for application/json ContentType.
type InviteCommunityRoleJSONRequestBody InviteCommunityRoleJSONBody

// CreateCommunityTopicJSONRequestBody defines body for CreateCommunityTopic for application/json ContentType.
type CreateCommunityTopicJSONRequestBody CreateCommunityTopicJSONBody

// CreateCommunityThreadJSONRequestBody defines body for CreateCommunityThread for application/json ContentType.
type CreateCommunityThreadJSONRequestBody CreateCommunityThreadJSONBody

// CreateCommunityPostJSONRequestBody defines body for CreateCommunityPost for application/json ContentType.
type CreateCommunityPostJSONRequestBody CreateCommunityPostJSONBody

// LikePostJSONRequestBody defines body for LikePost for application/json ContentType.
type LikePostJSONRequestBody LikePostJSONBody

// ReplyInviteJSONRequestBody defines body for ReplyInvite for application/json ContentType.
type ReplyInviteJSONRequestBody ReplyInviteJSONBody

// AsCommunity returns the union data inside the Activity_Where as a Community
func (t Activity_Where) AsCommunity() (Community, error) {
	var body Community
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommunity overwrites any union data inside the Activity_Where as the provided Community
func (t *Activity_Where) FromCommunity(v Community) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommunity performs a merge with any union data inside the Activity_Where, using the provided Community
func (t *Activity_Where) MergeCommunity(v Community) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Activity_Where) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Activity_Where) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUser returns the union data inside the Activity_Who as a User
func (t Activity_Who) AsUser() (User, error) {
	var body User
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUser overwrites any union data inside the Activity_Who as the provided User
func (t *Activity_Who) FromUser(v User) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUser performs a merge with any union data inside the Activity_Who, using the provided User
func (t *Activity_Who) MergeUser(v User) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMember returns the union data inside the Activity_Who as a Member
func (t Activity_Who) AsMember() (Member, error) {
	var body Member
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMember overwrites any union data inside the Activity_Who as the provided Member
func (t *Activity_Who) FromMember(v Member) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMember performs a merge with any union data inside the Activity_Who, using the provided Member
func (t *Activity_Who) MergeMember(v Member) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRole returns the union data inside the Activity_Who as a Role
func (t Activity_Who) AsRole() (Role, error) {
	var body Role
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRole overwrites any union data inside the Activity_Who as the provided Role
func (t *Activity_Who) FromRole(v Role) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRole performs a merge with any union data inside the Activity_Who, using the provided Role
func (t *Activity_Who) MergeRole(v Role) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Activity_Who) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Activity_Who) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsText returns the union data inside the Content_Entity as a Text
func (t Content_Entity) AsText() (Text, error) {
	var body Text
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromText overwrites any union data inside the Content_Entity as the provided Text
func (t *Content_Entity) FromText(v Text) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeText performs a merge with any union data inside the Content_Entity, using the provided Text
func (t *Content_Entity) MergeText(v Text) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsHeading returns the union data inside the Content_Entity as a Heading
func (t Content_Entity) AsHeading() (Heading, error) {
	var body Heading
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHeading overwrites any union data inside the Content_Entity as the provided Heading
func (t *Content_Entity) FromHeading(v Heading) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHeading performs a merge with any union data inside the Content_Entity, using the provided Heading
func (t *Content_Entity) MergeHeading(v Heading) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsList returns the union data inside the Content_Entity as a List
func (t Content_Entity) AsList() (List, error) {
	var body List
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromList overwrites any union data inside the Content_Entity as the provided List
func (t *Content_Entity) FromList(v List) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeList performs a merge with any union data inside the Content_Entity, using the provided List
func (t *Content_Entity) MergeList(v List) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCheckBox returns the union data inside the Content_Entity as a CheckBox
func (t Content_Entity) AsCheckBox() (CheckBox, error) {
	var body CheckBox
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckBox overwrites any union data inside the Content_Entity as the provided CheckBox
func (t *Content_Entity) FromCheckBox(v CheckBox) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckBox performs a merge with any union data inside the Content_Entity, using the provided CheckBox
func (t *Content_Entity) MergeCheckBox(v CheckBox) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRadioButton returns the union data inside the Content_Entity as a RadioButton
func (t Content_Entity) AsRadioButton() (RadioButton, error) {
	var body RadioButton
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRadioButton overwrites any union data inside the Content_Entity as the provided RadioButton
func (t *Content_Entity) FromRadioButton(v RadioButton) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRadioButton performs a merge with any union data inside the Content_Entity, using the provided RadioButton
func (t *Content_Entity) MergeRadioButton(v RadioButton) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsHorizontalLine returns the union data inside the Content_Entity as a HorizontalLine
func (t Content_Entity) AsHorizontalLine() (HorizontalLine, error) {
	var body HorizontalLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHorizontalLine overwrites any union data inside the Content_Entity as the provided HorizontalLine
func (t *Content_Entity) FromHorizontalLine(v HorizontalLine) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHorizontalLine performs a merge with any union data inside the Content_Entity, using the provided HorizontalLine
func (t *Content_Entity) MergeHorizontalLine(v HorizontalLine) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsImage returns the union data inside the Content_Entity as a Image
func (t Content_Entity) AsImage() (Image, error) {
	var body Image
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImage overwrites any union data inside the Content_Entity as the provided Image
func (t *Content_Entity) FromImage(v Image) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImage performs a merge with any union data inside the Content_Entity, using the provided Image
func (t *Content_Entity) MergeImage(v Image) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMentions returns the union data inside the Content_Entity as a Mentions
func (t Content_Entity) AsMentions() (Mentions, error) {
	var body Mentions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMentions overwrites any union data inside the Content_Entity as the provided Mentions
func (t *Content_Entity) FromMentions(v Mentions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMentions performs a merge with any union data inside the Content_Entity, using the provided Mentions
func (t *Content_Entity) MergeMentions(v Mentions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Content_Entity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Content_Entity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLogin returns the union data inside the Experience_Resource as a Login
func (t Experience_Resource) AsLogin() (Login, error) {
	var body Login
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLogin overwrites any union data inside the Experience_Resource as the provided Login
func (t *Experience_Resource) FromLogin(v Login) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLogin performs a merge with any union data inside the Experience_Resource, using the provided Login
func (t *Experience_Resource) MergeLogin(v Login) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCommunity returns the union data inside the Experience_Resource as a Community
func (t Experience_Resource) AsCommunity() (Community, error) {
	var body Community
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommunity overwrites any union data inside the Experience_Resource as the provided Community
func (t *Experience_Resource) FromCommunity(v Community) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommunity performs a merge with any union data inside the Experience_Resource, using the provided Community
func (t *Experience_Resource) MergeCommunity(v Community) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMember returns the union data inside the Experience_Resource as a Member
func (t Experience_Resource) AsMember() (Member, error) {
	var body Member
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMember overwrites any union data inside the Experience_Resource as the provided Member
func (t *Experience_Resource) FromMember(v Member) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMember performs a merge with any union data inside the Experience_Resource, using the provided Member
func (t *Experience_Resource) MergeMember(v Member) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRole returns the union data inside the Experience_Resource as a Role
func (t Experience_Resource) AsRole() (Role, error) {
	var body Role
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRole overwrites any union data inside the Experience_Resource as the provided Role
func (t *Experience_Resource) FromRole(v Role) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRole performs a merge with any union data inside the Experience_Resource, using the provided Role
func (t *Experience_Resource) MergeRole(v Role) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTopic returns the union data inside the Experience_Resource as a Topic
func (t Experience_Resource) AsTopic() (Topic, error) {
	var body Topic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTopic overwrites any union data inside the Experience_Resource as the provided Topic
func (t *Experience_Resource) FromTopic(v Topic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTopic performs a merge with any union data inside the Experience_Resource, using the provided Topic
func (t *Experience_Resource) MergeTopic(v Topic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPost returns the union data inside the Experience_Resource as a Post
func (t Experience_Resource) AsPost() (Post, error) {
	var body Post
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPost overwrites any union data inside the Experience_Resource as the provided Post
func (t *Experience_Resource) FromPost(v Post) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePost performs a merge with any union data inside the Experience_Resource, using the provided Post
func (t *Experience_Resource) MergePost(v Post) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLike returns the union data inside the Experience_Resource as a Like
func (t Experience_Resource) AsLike() (Like, error) {
	var body Like
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLike overwrites any union data inside the Experience_Resource as the provided Like
func (t *Experience_Resource) FromLike(v Like) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLike performs a merge with any union data inside the Experience_Resource, using the provided Like
func (t *Experience_Resource) MergeLike(v Like) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Experience_Resource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Experience_Resource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInsertedLineMessage returns the union data inside the MessagesToRecieve_Entity as a InsertedLineMessage
func (t MessagesToRecieve_Entity) AsInsertedLineMessage() (InsertedLineMessage, error) {
	var body InsertedLineMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsertedLineMessage overwrites any union data inside the MessagesToRecieve_Entity as the provided InsertedLineMessage
func (t *MessagesToRecieve_Entity) FromInsertedLineMessage(v InsertedLineMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsertedLineMessage performs a merge with any union data inside the MessagesToRecieve_Entity, using the provided InsertedLineMessage
func (t *MessagesToRecieve_Entity) MergeInsertedLineMessage(v InsertedLineMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovedLineMessage returns the union data inside the MessagesToRecieve_Entity as a MovedLineMessage
func (t MessagesToRecieve_Entity) AsMovedLineMessage() (MovedLineMessage, error) {
	var body MovedLineMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovedLineMessage overwrites any union data inside the MessagesToRecieve_Entity as the provided MovedLineMessage
func (t *MessagesToRecieve_Entity) FromMovedLineMessage(v MovedLineMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovedLineMessage performs a merge with any union data inside the MessagesToRecieve_Entity, using the provided MovedLineMessage
func (t *MessagesToRecieve_Entity) MergeMovedLineMessage(v MovedLineMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEditedLineMessage returns the union data inside the MessagesToRecieve_Entity as a EditedLineMessage
func (t MessagesToRecieve_Entity) AsEditedLineMessage() (EditedLineMessage, error) {
	var body EditedLineMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEditedLineMessage overwrites any union data inside the MessagesToRecieve_Entity as the provided EditedLineMessage
func (t *MessagesToRecieve_Entity) FromEditedLineMessage(v EditedLineMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEditedLineMessage performs a merge with any union data inside the MessagesToRecieve_Entity, using the provided EditedLineMessage
func (t *MessagesToRecieve_Entity) MergeEditedLineMessage(v EditedLineMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeletedLineMessage returns the union data inside the MessagesToRecieve_Entity as a DeletedLineMessage
func (t MessagesToRecieve_Entity) AsDeletedLineMessage() (DeletedLineMessage, error) {
	var body DeletedLineMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeletedLineMessage overwrites any union data inside the MessagesToRecieve_Entity as the provided DeletedLineMessage
func (t *MessagesToRecieve_Entity) FromDeletedLineMessage(v DeletedLineMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeletedLineMessage performs a merge with any union data inside the MessagesToRecieve_Entity, using the provided DeletedLineMessage
func (t *MessagesToRecieve_Entity) MergeDeletedLineMessage(v DeletedLineMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessagesToRecieve_Entity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessagesToRecieve_Entity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCurrentLinesMessage returns the union data inside the MessagesToSend_Entity as a CurrentLinesMessage
func (t MessagesToSend_Entity) AsCurrentLinesMessage() (CurrentLinesMessage, error) {
	var body CurrentLinesMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCurrentLinesMessage overwrites any union data inside the MessagesToSend_Entity as the provided CurrentLinesMessage
func (t *MessagesToSend_Entity) FromCurrentLinesMessage(v CurrentLinesMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCurrentLinesMessage performs a merge with any union data inside the MessagesToSend_Entity, using the provided CurrentLinesMessage
func (t *MessagesToSend_Entity) MergeCurrentLinesMessage(v CurrentLinesMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessagesToSend_Entity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessagesToSend_Entity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// サービスの利用者が制御可能なアクションを取得する
	// (GET /action)
	ListAction(ctx echo.Context) error
	// コミュニティを作成する
	// (POST /community)
	CreateCommunity(ctx echo.Context) error
	// コミュニティを更新する
	// (PATCH /community/{community_id})
	UpdateCommunity(ctx echo.Context, communityId ID) error
	// コミュニティの招待を取得する
	// (GET /community/{community_id}/invite)
	ListCommunityInvite(ctx echo.Context, communityId ID, params ListCommunityInviteParams) error
	// コミュニティの招待を削除する
	// (DELETE /community/{community_id}/invite/{invite_id})
	DeleteCommunityInvite(ctx echo.Context, communityId ID, inviteId ID) error
	// コミュニティのメンバーを取得する
	// (GET /community/{community_id}/member)
	ListCommunityMember(ctx echo.Context, communityId ID, params ListCommunityMemberParams) error
	// コミュニティのメンバーの詳細を取得する
	// (GET /community/{community_id}/member/{member_id})
	GetCommunityMember(ctx echo.Context, communityId ID, memberId ID) error
	// コミュニティの説明を編集する
	// (GET /community/{community_id}/note)
	EditCommunityDescription(ctx echo.Context, communityId ID, params EditCommunityDescriptionParams) error
	// コミュニティのロールを取得する
	// (GET /community/{community_id}/role)
	ListCommunityRole(ctx echo.Context, communityId ID) error
	// コミュニティのロールを作成する
	// (POST /community/{community_id}/role)
	CreateCommunityRole(ctx echo.Context, communityId ID) error
	// コミュニティのロールを削除する
	// (DELETE /community/{community_id}/role/{role_id})
	DeleteCommunityRole(ctx echo.Context, communityId ID, roleId ID) error
	// コミュニティのロールを更新する
	// (PATCH /community/{community_id}/role/{role_id})
	UpdateCommunityRole(ctx echo.Context, communityId ID, roleId ID) error
	// コミュニティのロールに招待する
	// (POST /community/{community_id}/role/{role_id}/invite)
	InviteCommunityRole(ctx echo.Context, communityId ID, roleId ID) error
	// コミュニティのトピックを取得する
	// (GET /community/{community_id}/topic)
	ListCommunityTopic(ctx echo.Context, communityId ID, params ListCommunityTopicParams) error
	// コミュニティのトピックを作成する
	// (POST /community/{community_id}/topic)
	CreateCommunityTopic(ctx echo.Context, communityId ID) error
	// トピックのスレッドを取得する
	// (GET /community/{community_id}/topic/{topic_id})
	ListCommunityThread(ctx echo.Context, communityId ID, topicId ID, params ListCommunityThreadParams) error
	// トピックにスレッドを作成する（ポストする）
	// (POST /community/{community_id}/topic/{topic_id})
	CreateCommunityThread(ctx echo.Context, communityId ID, topicId ID) error
	// スレッドのポストを取得する
	// (GET /community/{community_id}/topic/{topic_id}/thread/{thread_id})
	ListCommunityPost(ctx echo.Context, communityId ID, topicId ID, threadId ID, params ListCommunityPostParams) error
	// スレッドにポストを作成する（リプライする）
	// (POST /community/{community_id}/topic/{topic_id}/thread/{thread_id})
	CreateCommunityPost(ctx echo.Context, communityId ID, topicId ID, threadId ID) error
	// ポストの支持/不支持の内容を取得する
	// (GET /community/{community_id}/topic/{topic_id}/thread/{thread_id}/post/{post_id}/like)
	ListPostLike(ctx echo.Context, communityId ID, topicId ID, threadId ID, postId ID, params ListPostLikeParams) error
	// ポストに対し支持/不支持を表明する
	// (POST /community/{community_id}/topic/{topic_id}/thread/{thread_id}/post/{post_id}/like)
	LikePost(ctx echo.Context, communityId ID, topicId ID, threadId ID, postId ID) error
	// 認証済みユーザーの招待を取得する
	// (GET /user/invite)
	ListUserInvite(ctx echo.Context, params ListUserInviteParams) error
	// 認証済みユーザーの招待に応答する
	// (DELETE /user/invite/{invite_id})
	ReplyInvite(ctx echo.Context, inviteId ID) error
	// 認証済みユーザーのログイン履歴を取得する
	// (GET /user/login)
	ListUserLoginActivity(ctx echo.Context, params ListUserLoginActivityParams) error
	// 認証済みユーザーのプロフィールを編集する
	// (GET /user/note)
	EditUserProfile(ctx echo.Context, params EditUserProfileParams) error
	// ユーザーアクティビティを取得する
	// (GET /user/{user_id}/activity)
	ListUserActivity(ctx echo.Context, userId ID, params ListUserActivityParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAction converts echo context to params.
func (w *ServerInterfaceWrapper) ListAction(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAction(ctx)
	return err
}

// CreateCommunity converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCommunity(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCommunity(ctx)
	return err
}

// UpdateCommunity converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCommunity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateCommunity(ctx, communityId)
	return err
}

// ListCommunityInvite converts echo context to params.
func (w *ServerInterfaceWrapper) ListCommunityInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCommunityInviteParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCommunityInvite(ctx, communityId, params)
	return err
}

// DeleteCommunityInvite converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCommunityInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "invite_id" -------------
	var inviteId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, ctx.Param("invite_id"), &inviteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invite_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCommunityInvite(ctx, communityId, inviteId)
	return err
}

// ListCommunityMember converts echo context to params.
func (w *ServerInterfaceWrapper) ListCommunityMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCommunityMemberParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCommunityMember(ctx, communityId, params)
	return err
}

// GetCommunityMember converts echo context to params.
func (w *ServerInterfaceWrapper) GetCommunityMember(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "member_id" -------------
	var memberId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "member_id", runtime.ParamLocationPath, ctx.Param("member_id"), &memberId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter member_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCommunityMember(ctx, communityId, memberId)
	return err
}

// EditCommunityDescription converts echo context to params.
func (w *ServerInterfaceWrapper) EditCommunityDescription(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params EditCommunityDescriptionParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "Connection" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Connection")]; found {
		var Connection string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Connection, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Connection", runtime.ParamLocationHeader, valueList[0], &Connection)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Connection: %s", err))
		}

		params.Connection = Connection
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Connection is required, but not found"))
	}
	// ------------- Required header parameter "Upgrade" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Upgrade")]; found {
		var Upgrade string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Upgrade, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Upgrade", runtime.ParamLocationHeader, valueList[0], &Upgrade)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Upgrade: %s", err))
		}

		params.Upgrade = Upgrade
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Upgrade is required, but not found"))
	}
	// ------------- Required header parameter "Sec-WebSocket-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Sec-WebSocket-Key")]; found {
		var SecWebSocketKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Sec-WebSocket-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Sec-WebSocket-Key", runtime.ParamLocationHeader, valueList[0], &SecWebSocketKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Sec-WebSocket-Key: %s", err))
		}

		params.SecWebSocketKey = SecWebSocketKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Sec-WebSocket-Key is required, but not found"))
	}
	// ------------- Required header parameter "Sec-WebSocket-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Sec-WebSocket-Version")]; found {
		var SecWebSocketVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Sec-WebSocket-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Sec-WebSocket-Version", runtime.ParamLocationHeader, valueList[0], &SecWebSocketVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Sec-WebSocket-Version: %s", err))
		}

		params.SecWebSocketVersion = SecWebSocketVersion
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Sec-WebSocket-Version is required, but not found"))
	}
	// ------------- Required header parameter "Sec-WebSocket-Extensions" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Sec-WebSocket-Extensions")]; found {
		var SecWebSocketExtensions string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Sec-WebSocket-Extensions, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Sec-WebSocket-Extensions", runtime.ParamLocationHeader, valueList[0], &SecWebSocketExtensions)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Sec-WebSocket-Extensions: %s", err))
		}

		params.SecWebSocketExtensions = SecWebSocketExtensions
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Sec-WebSocket-Extensions is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EditCommunityDescription(ctx, communityId, params)
	return err
}

// ListCommunityRole converts echo context to params.
func (w *ServerInterfaceWrapper) ListCommunityRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCommunityRole(ctx, communityId)
	return err
}

// CreateCommunityRole converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCommunityRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCommunityRole(ctx, communityId)
	return err
}

// DeleteCommunityRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCommunityRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "role_id" -------------
	var roleId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "role_id", runtime.ParamLocationPath, ctx.Param("role_id"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteCommunityRole(ctx, communityId, roleId)
	return err
}

// UpdateCommunityRole converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCommunityRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "role_id" -------------
	var roleId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "role_id", runtime.ParamLocationPath, ctx.Param("role_id"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateCommunityRole(ctx, communityId, roleId)
	return err
}

// InviteCommunityRole converts echo context to params.
func (w *ServerInterfaceWrapper) InviteCommunityRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "role_id" -------------
	var roleId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "role_id", runtime.ParamLocationPath, ctx.Param("role_id"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InviteCommunityRole(ctx, communityId, roleId)
	return err
}

// ListCommunityTopic converts echo context to params.
func (w *ServerInterfaceWrapper) ListCommunityTopic(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCommunityTopicParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCommunityTopic(ctx, communityId, params)
	return err
}

// CreateCommunityTopic converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCommunityTopic(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCommunityTopic(ctx, communityId)
	return err
}

// ListCommunityThread converts echo context to params.
func (w *ServerInterfaceWrapper) ListCommunityThread(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "topic_id" -------------
	var topicId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "topic_id", runtime.ParamLocationPath, ctx.Param("topic_id"), &topicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topic_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCommunityThreadParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCommunityThread(ctx, communityId, topicId, params)
	return err
}

// CreateCommunityThread converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCommunityThread(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "topic_id" -------------
	var topicId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "topic_id", runtime.ParamLocationPath, ctx.Param("topic_id"), &topicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topic_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCommunityThread(ctx, communityId, topicId)
	return err
}

// ListCommunityPost converts echo context to params.
func (w *ServerInterfaceWrapper) ListCommunityPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "topic_id" -------------
	var topicId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "topic_id", runtime.ParamLocationPath, ctx.Param("topic_id"), &topicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topic_id: %s", err))
	}

	// ------------- Path parameter "thread_id" -------------
	var threadId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, ctx.Param("thread_id"), &threadId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thread_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCommunityPostParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCommunityPost(ctx, communityId, topicId, threadId, params)
	return err
}

// CreateCommunityPost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCommunityPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "topic_id" -------------
	var topicId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "topic_id", runtime.ParamLocationPath, ctx.Param("topic_id"), &topicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topic_id: %s", err))
	}

	// ------------- Path parameter "thread_id" -------------
	var threadId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, ctx.Param("thread_id"), &threadId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thread_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCommunityPost(ctx, communityId, topicId, threadId)
	return err
}

// ListPostLike converts echo context to params.
func (w *ServerInterfaceWrapper) ListPostLike(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "topic_id" -------------
	var topicId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "topic_id", runtime.ParamLocationPath, ctx.Param("topic_id"), &topicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topic_id: %s", err))
	}

	// ------------- Path parameter "thread_id" -------------
	var threadId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, ctx.Param("thread_id"), &threadId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thread_id: %s", err))
	}

	// ------------- Path parameter "post_id" -------------
	var postId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "post_id", runtime.ParamLocationPath, ctx.Param("post_id"), &postId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter post_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPostLikeParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Required query parameter "like" -------------

	err = runtime.BindQueryParameter("form", true, true, "like", ctx.QueryParams(), &params.Like)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter like: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPostLike(ctx, communityId, topicId, threadId, postId, params)
	return err
}

// LikePost converts echo context to params.
func (w *ServerInterfaceWrapper) LikePost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "community_id" -------------
	var communityId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "community_id", runtime.ParamLocationPath, ctx.Param("community_id"), &communityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter community_id: %s", err))
	}

	// ------------- Path parameter "topic_id" -------------
	var topicId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "topic_id", runtime.ParamLocationPath, ctx.Param("topic_id"), &topicId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter topic_id: %s", err))
	}

	// ------------- Path parameter "thread_id" -------------
	var threadId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, ctx.Param("thread_id"), &threadId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thread_id: %s", err))
	}

	// ------------- Path parameter "post_id" -------------
	var postId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "post_id", runtime.ParamLocationPath, ctx.Param("post_id"), &postId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter post_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LikePost(ctx, communityId, topicId, threadId, postId)
	return err
}

// ListUserInvite converts echo context to params.
func (w *ServerInterfaceWrapper) ListUserInvite(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserInviteParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUserInvite(ctx, params)
	return err
}

// ReplyInvite converts echo context to params.
func (w *ServerInterfaceWrapper) ReplyInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "invite_id" -------------
	var inviteId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, ctx.Param("invite_id"), &inviteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter invite_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReplyInvite(ctx, inviteId)
	return err
}

// ListUserLoginActivity converts echo context to params.
func (w *ServerInterfaceWrapper) ListUserLoginActivity(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserLoginActivityParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUserLoginActivity(ctx, params)
	return err
}

// EditUserProfile converts echo context to params.
func (w *ServerInterfaceWrapper) EditUserProfile(ctx echo.Context) error {
	var err error

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params EditUserProfileParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "Connection" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Connection")]; found {
		var Connection string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Connection, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Connection", runtime.ParamLocationHeader, valueList[0], &Connection)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Connection: %s", err))
		}

		params.Connection = Connection
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Connection is required, but not found"))
	}
	// ------------- Required header parameter "Upgrade" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Upgrade")]; found {
		var Upgrade string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Upgrade, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Upgrade", runtime.ParamLocationHeader, valueList[0], &Upgrade)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Upgrade: %s", err))
		}

		params.Upgrade = Upgrade
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Upgrade is required, but not found"))
	}
	// ------------- Required header parameter "Sec-WebSocket-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Sec-WebSocket-Key")]; found {
		var SecWebSocketKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Sec-WebSocket-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Sec-WebSocket-Key", runtime.ParamLocationHeader, valueList[0], &SecWebSocketKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Sec-WebSocket-Key: %s", err))
		}

		params.SecWebSocketKey = SecWebSocketKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Sec-WebSocket-Key is required, but not found"))
	}
	// ------------- Required header parameter "Sec-WebSocket-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Sec-WebSocket-Version")]; found {
		var SecWebSocketVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Sec-WebSocket-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Sec-WebSocket-Version", runtime.ParamLocationHeader, valueList[0], &SecWebSocketVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Sec-WebSocket-Version: %s", err))
		}

		params.SecWebSocketVersion = SecWebSocketVersion
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Sec-WebSocket-Version is required, but not found"))
	}
	// ------------- Required header parameter "Sec-WebSocket-Extensions" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Sec-WebSocket-Extensions")]; found {
		var SecWebSocketExtensions string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Sec-WebSocket-Extensions, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Sec-WebSocket-Extensions", runtime.ParamLocationHeader, valueList[0], &SecWebSocketExtensions)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Sec-WebSocket-Extensions: %s", err))
		}

		params.SecWebSocketExtensions = SecWebSocketExtensions
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Sec-WebSocket-Extensions is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EditUserProfile(ctx, params)
	return err
}

// ListUserActivity converts echo context to params.
func (w *ServerInterfaceWrapper) ListUserActivity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId ID

	err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationPath, ctx.Param("user_id"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(SessionScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserActivityParams
	// ------------- Required query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, true, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUserActivity(ctx, userId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/action", wrapper.ListAction)
	router.POST(baseURL+"/community", wrapper.CreateCommunity)
	router.PATCH(baseURL+"/community/:community_id", wrapper.UpdateCommunity)
	router.GET(baseURL+"/community/:community_id/invite", wrapper.ListCommunityInvite)
	router.DELETE(baseURL+"/community/:community_id/invite/:invite_id", wrapper.DeleteCommunityInvite)
	router.GET(baseURL+"/community/:community_id/member", wrapper.ListCommunityMember)
	router.GET(baseURL+"/community/:community_id/member/:member_id", wrapper.GetCommunityMember)
	router.GET(baseURL+"/community/:community_id/note", wrapper.EditCommunityDescription)
	router.GET(baseURL+"/community/:community_id/role", wrapper.ListCommunityRole)
	router.POST(baseURL+"/community/:community_id/role", wrapper.CreateCommunityRole)
	router.DELETE(baseURL+"/community/:community_id/role/:role_id", wrapper.DeleteCommunityRole)
	router.PATCH(baseURL+"/community/:community_id/role/:role_id", wrapper.UpdateCommunityRole)
	router.POST(baseURL+"/community/:community_id/role/:role_id/invite", wrapper.InviteCommunityRole)
	router.GET(baseURL+"/community/:community_id/topic", wrapper.ListCommunityTopic)
	router.POST(baseURL+"/community/:community_id/topic", wrapper.CreateCommunityTopic)
	router.GET(baseURL+"/community/:community_id/topic/:topic_id", wrapper.ListCommunityThread)
	router.POST(baseURL+"/community/:community_id/topic/:topic_id", wrapper.CreateCommunityThread)
	router.GET(baseURL+"/community/:community_id/topic/:topic_id/thread/:thread_id", wrapper.ListCommunityPost)
	router.POST(baseURL+"/community/:community_id/topic/:topic_id/thread/:thread_id", wrapper.CreateCommunityPost)
	router.GET(baseURL+"/community/:community_id/topic/:topic_id/thread/:thread_id/post/:post_id/like", wrapper.ListPostLike)
	router.POST(baseURL+"/community/:community_id/topic/:topic_id/thread/:thread_id/post/:post_id/like", wrapper.LikePost)
	router.GET(baseURL+"/user/invite", wrapper.ListUserInvite)
	router.DELETE(baseURL+"/user/invite/:invite_id", wrapper.ReplyInvite)
	router.GET(baseURL+"/user/login", wrapper.ListUserLoginActivity)
	router.GET(baseURL+"/user/note", wrapper.EditUserProfile)
	router.GET(baseURL+"/user/:user_id/activity", wrapper.ListUserActivity)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
